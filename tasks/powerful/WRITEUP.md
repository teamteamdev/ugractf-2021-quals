# Мощный шифр: Write-up

В этом задании участникам предлагалось расшифровать некоторое сообщение. Был дан ключ, само зашифрованное сообщение и даже скрипт для расшифровки. Кажется, что всё более чем элементарно — просто запустить скрипт и всё готово. Однако, не тут-то было:

```
$ python3 decrypt.py powerful.key 
RRSSA DECODER
=============
WARNING! This script might work slowly, please wait patiently and don't interrupt the execution!
Enter your encrypted data: 7694194 15390722 14368614 19069969 23723442 16624648 2394527 34888380 22598911 11441468 8290797 17392772 22533699 3593467 8223017
Your data is: ugr
```

На трёх символах скрипт зависает и не подаёт никаких признаков жизни, кроме потребления 100% мощностей одного ядра.

Прервав скрипт (несмотря на явное прупреждение о том, что делать этого не надо), видим, что выполнение скрипта падает на строке

```python
x = (a ** b) ** (c ** d)
```

На Python `**` означает возведение в степень. Давайте посмотрим, что же возводится, и в какую степень. Видим, что дешифрование производится блоками по три символа. _a_ — как раз очередной элемент из потока зашифрованных данных.

Остальные переменные берутся из `powerful.key` — это файл с данными, закодированными в base64, внутри которого лежит JSON. В `private_key` лежат пары `(c, d)`, а в `common_key` — пары `(b, n)`. Число _n_ используется чуть позже: для получения символов используется не само число _x_, а его остаток от деления на _n_.

Первое число вычисляется быстро: в ключе `b = c = d = 1`, и мы получаем первые три символа флага: `ugr`. Все же остальные числа имеют длину 20–30 бит (7–9 десятичных знаков), и даже одно возведение в степень уже вряд ли вычислится на среднем современном процессоре.

Дальше будут использованы несколько математических терминов. Под _вычислением по модулю n_ мы будем понимать вычисление остатка от деления на _n_. Два числа называются _сравнимыми_ или _равными по модулю n_, если их остатки от деления на _n_ равны. Разумеется, везде, где не сказано иное, подразумеваются целые неотрицательные числа. _Взаимно простыми_ числами называются два таких числа, у которых нет общего делителя, кроме единицы.

Давайте придумаем, как соптимизировать вычисление. Во-первых, довольно логично, что раз мы результат берём по модулю, можно брать по модулю результат на каждой итерации. В Python это проще всего записать так: `pow(a ** b, c ** d, n)`. Функция `pow` в Python с тремя аргументами эффективно вычисляет степень числа по нужному модулю.

Эта оптимизация уже сильно упрощает процесс, но этого мало. Рассмотрим выражение _a_<sup>_b_</sup> mod _n_, где _a_ > _n_. _a_ представимо в виде _a_ = _kn_ + _x_, где _x_ = _a_ mod _n_. Тогда (_kn_ + _x_)<sup>_b_</sup> = _kn_<sup>_b_</sup> + _b_(_kn_)<sup>_b_ − 1</sup>_x_ + … + _x_<sup>_b_</sup>. И, поскольку все элементы, кроме последнего, делятся на _n_, то выражение сравнимо с _x_<sup>_b_</sup> по модулю _n_.

Таким образом, от выражения _a_<sup>_b_</sup> нас интересует только остаток от деления на _n_, и наше выражение превращается в `pow(pow(a, b, n), c ** d, n)`. Соптимизировать _c_<sup>_d_</sup> таким же образом не выйдет — к сожалению, мы получим другой результат.

Назовём наше число `pow(a, b, n)` буквой _q_. Мы хотим посчитать остаток от деления _e_ в некоторой степени на _n_. Рассмотрим последовательность: _q_ mod _n_, _q_<sup>2</sup> mod _n_, _q_<sup>3</sup> mod _n_ …. Все эти числа лежат в диапазоне от 1 до _n_ − 1.

> Здесь мы используем тот факт, что _q_ и _n_ взаимно просты. Это было верно для наших сообщений (и в целом, подобные условия нередко являются обязательными для различных криптографических систем), но в общем случае такие вещи стоит проверять, чтобы не ошибиться.

Очевидно, что рано или поздно остатки начнут повторяться — хотя бы на _n_-той операции. При этом если мы какой-то повторяющийся остаток снова умножим на _q_, то получим то же самое число — таким образом, последовательность зацикливается. Если мы найдём длину этого цикла, возводить в нужную степень и не придётся — все итерации цикла можно просто пропустить, вычислив вместо нужной степени остаток от её деления на длину цикла.

Поскольку наш модуль был небольшим, можно было просто перебрать все степени _q_, пока мы не встретим этот самый цикл. Но, на самом деле, за нас уже всё сделал Леонард Эйлер — его [теорема](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%AD%D0%B9%D0%BB%D0%B5%D1%80%D0%B0_(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D1%87%D0%B8%D1%81%D0%B5%D0%BB)) гласит о том, что длина такого цикла для взаимнопростых _q_ и _n_ равна функции Эйлера числа _n_. Функция Эйлера _φ_(_n_) — это количество натуральных чисел, меньших _n_ и взаимно простых с ним.

Опять же, её можно посчитать и наивно, но с помощью несложных математических преобразований можно вычислить функцию Эйлера, зная делители _n_.

Таким образом, итоговая формула приобретает такой вид:

```python
pow(pow(a, b, n), pow(c, d, phi(n)), n)
```

Используя её, мы мгновенно получаем флаг.

Флаг: **ugra_it_is_too_powerful_rsa_right_f753a15a12c**
