# Сертификация соответствия: Write-up

Нас встречает форма сертификации соответствия ЗАО «Намбо-М» с полями, запрашивающими личную информацию, и требованиями, абсурдность которых прогрессирует по мере заполнения формы. Всё лишь для того, чтобы отсеять тех, кто недостоин сотрудничать с компанией (кстати, некоторые названия юридических лиц иногда бывает полезно прочитать задом наперёд).

По мере попыток заполнить форму выясняем, что иногда возникает ошибка 405 Not Allowed, и запрос приходится повторять.

После попытки заполнить форму в адресе страницы появляется index.php. Неплохо бы выяснить, что за версия PHP используется — возможно, это поможет нам преодолевать валидацию. И почему возникают эти странные 405, ведь мы делаем POST-запрос к форме, и большую часть времени всё работает нормально.

Откроем вкладку Network инспектора, чтобы совершаемые нами запросы записывались для подробного изучения. Видим в заголовках ответа (Response Headers) заголовок X-Powered-By, но вот что удивительно: там написано то `PHP/7.4.15`, то `PHP/8.0.2`, а у страниц ошибки 405 заголовок отсутствует вовсе.

Похоже, мы имеем дело с балансировкой нагрузки между серверами, настроенными по-разному; попадать на тот или иной сервер можно повторением запросов. Раз серверу, отдающему ошибку 405, не нравится метод POST, попробуем поделать обычные GET-запросы, пока не попадём на него. А когда всё-таки попадём, мы получим — скорее всего, в виде скачанного файла, но возможно, отображённый в виде страницы — некий файл index.php. Попавшийся сервер просто не обрабатывает PHP и отдаёт эти файлы как статические — так что теперь у нас есть исходный код этой формы.

Получение флага и даже его расчёт упрятаны в недоступный нам файл flag.py, который вызывается только на последнем шаге формы, поэтому нам придётся всё-таки понять, как её заполнить. Бросается в глаза огромная функция `validate_fields` — найдём там упоминания полей, которые не получается преодолеть сходу.

Прежде всего сталкиваемся с полем «Количество транспортных средств, находящихся в пользовании по иным основаниям» (`vehcount2`) на втором шаге.

```php
if (@$form["vehcount2"] != 0) {
    $errors["vehcount2"] = "Вы не можете пользоваться иными ТС во избежание конфликта интересов.";
}
if (@$form["vehcount2"] == "0") {
    $errors["vehcount2"] = "Нельзя указывать значение 0 в данном поле!";
}
if (empty(@$form["vehcount2"])) {
    $errors["vehcount2"] = "Поле не может быть пустым!";
}
```

Требования кажутся взаимоисключающими: ноль нельзя, не ноль нельзя, и зачем-то в явном виде пустое значение тоже нельзя. Однако сравнения с нулём различаются: в первом случае строка из формы сравнивается с числом `0`, во втором — со строкой `"0"`. Итак, нам нужна строка, при сравнении с числом дающая true, а при сравнении со строкой — false. Смотрим [таблицу сравнений в документации](https://www.php.net/manual/en/types.comparisons.php#types.comparisions-loose) и обнаруживаем, что произвольная нечисловая строка вроде `"php"` обладает нужными свойствами. Вводим её в поле.

На третьем шаге нас поджидают поля «Количество детей» (`children`) и «Возраст детей» (`cage`).

```php
if (@$form["children"] <= 1) {
    $errors["children"] = "Вы <u>ДОЛЖНЫ</u> обладать хотя бы двумя детьми для работы с нашей компанией!!";
}
if (@$form["children"] >= 2) {
    $errors["children"] = "Форма не поддерживает указание более чем одного ребёнка. Укажите одного ребёнка.";
}
```

Требуют указать число, большее 1, но меньшее 2. Для целых неотрицательных чисел, таких как количество детей, это взаимоисключающие требования, но тип данных никто не проверяет, а значит, можно указать, например, `1.5`.

```php
if (@$form["cage"] == 0) {
    $errors["cage"] = "Укажите возраст Вашего ребёнка.";
}
if (@$form["cage"] == "") {
    $errors["cage"] = "Поле не может быть пустым!";
}
if ((int)(@$form["cage"]) != "11") {
    $errors["cage"] = "Указанное значение не отражает возраст Ваших детей.";
}
if (@$form["cage"] == 11) {
    $errors["cage"] = "Вы не можете указывать какое попало значение в это поле. Отнеситесь к заполнению формы серьёзно.";
}

```

11 — это «какое попало» значение, а не 11 указывать нельзя, потому что это число, по мнению формы, не отражает возраст детей. Опять видим странности в сравнении: на этот раз явно полученное из значения число сравнивается со строкой, а строка — наоборот, с числом. Смотрим в [документации про числовые строки](https://www.php.net/manual/en/language.types.numeric-strings.php), как работает приведение типов. Узнаём про понятие _префиксной_ числовой строки (вроде `"11abcd"`), которое рассматривается или не рассматривается как число, в зависимости от контекста.

С одной стороны, числовая строка должна обязательно соответствовать числу 11, чтобы пройти третье условие, строка `"11abcd"` здесь подходит. С другой стороны, сравнение строки с числом 11 должно быть ложным, и вот тут поведение PHP 7 и PHP 8 различается: PHP 7 приводит префиксную числовую строку к числу, так что проскочить условие никак не получается. А вот PHP 8 префиксную числовую строку в этом контексте за число не считает, сравнение даёт результат false, и форма проходит валидацию.

Повторяем запрос несколько раз, чтобы он точно был обработан версией 8; можно это сделать, несколько раз нажав на кнопку, потому что в версии 7 валидация не проходит.

На четвёртом шаге, к нашему удивлению, не встречаем никаких препятствий, а на пятом и вовсе обнаруживаем «код подтверждения», то есть флаг.

Флаг: **ugra_said_secret_service_secretly_succumbs_c9061152e8a7**
